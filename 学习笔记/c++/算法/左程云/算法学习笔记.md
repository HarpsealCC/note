# 算法学习笔记

## 常见的算法思想
### 递归

递归算法是一种通过函数调用自身来解决问题的编程方法。递归的核心思想是将一个复杂的问题逐步分解为规模更小的子问题，并通过解决这些子问题来得到原问题的解。递归在许多算法中得到了广泛的应用，如树的遍历、斐波那契数列、全排列生成、动态规划等。

#### 递归的核心思想
递归的核心思想是将一个问题分解为规模更小的同类问题，并通过递归调用来逐步解决这些子问题，直到达到可以直接求解的基准情况。

递归通常需要满足以下两个条件：

基准情况（Base Case）：这是递归停止的条件，通常是最小规模的问题，当问题达到基准情况时，递归不会再继续调用自身，而是直接返回结果。

递归步骤（Recursive Step）：将问题分解为一个或多个规模更小的同类问题，通过递归调用函数本身来解决这些子问题。

#### 经典题型
斐波那契数列, 快速排序

### 回溯
回溯算法是一种系统地搜索问题解空间的方法，主要用于解决组合、排列、子集等问题。它的核心思想是通过逐步构建解决方案，并在每一步选择中尝试所有可能的选项。如果当前选择导致问题无解或不满足约束条件，则撤销（回溯）上一步的选择，尝试其他可能性。
#### 回溯算法的核心思想
1. 构建解空间树：

    回溯算法通常会把问题的求解过程抽象为一棵树（解空间树），每个节点表示当前问题的一个部分解。
    从树的根节点开始，通过不同的选择逐步扩展节点，直到形成一个完整的解。

2. 深度优先搜索（DFS）：

    回溯算法通过深度优先搜索的方式在解空间树中遍历，从根节点出发，逐层深入搜索，直到找到一个解或到达树的叶子节点。
    在搜索过程中，遇到不符合条件的节点或叶子节点时，算法会返回到上一层（即回溯），尝试其他路径。

3. 状态重置（回溯）：

    在深入到下一层决策前，回溯算法会做出选择，将某个选项加入当前解。
    如果发现当前解不可行（即不满足问题的约束条件），回溯算法会撤销之前的选择（即回溯），并尝试其他可能的选项。

4. 剪枝：

    在搜索过程中，回溯算法经常结合剪枝策略来减少不必要的搜索，提前排除某些无效的解空间分支，从而提高效率。
#### 回溯算法的一般步骤
1. 选择候选：在当前步骤，根据问题的要求选择所有可能的候选。
2. 判断是否满足条件：检查当前部分解是否满足问题的要求。
    - 如果满足条件，继续尝试扩展当前部分解。
    - 如果不满足条件，回溯到上一步并尝试其他选择。(可以由递归函数开始进行此操作)
3. 递归探索：对于每个选择，递归地尝试进一步构建解。
4. 回溯：如果递归探索发现当前选择不能导致问题的解，撤销选择并返回上一步尝试其他路径。

### 回溯算法的应用场景
- 组合问题：如求解组合总和、求解子集、求解排列等。
- 图的搜索问题：如迷宫问题、八皇后问题、图的着色问题等。
- 字符串问题：如求解字符串的全排列、括号生成问题等。
- 决策树问题：如解数独问题。
#### 经典题型
leecode 39. 组合总和
### 双指针法

双指针法是一种常见且高效的算法思想，常用于解决数组或链表中的各种问题。它通过同时操作两个指针，使得某些问题能够在
O(n) 的时间复杂度内得到解决。双指针法的关键在于如何合理地设置和移动这两个指针，以达到预期的效果。

#### 双指针法的核心思想
双指针法的核心思想是通过两个指针在数据结构（如数组或链表）上的移动来缩小问题的规模或范围。这两个指针可以根据问题的不同，采取不同的移动方式和策略。常见的双指针类型有以下几种：

1. 快慢指针：

    快指针 每次移动两步，慢指针 每次移动一步。
    主要用于检测链表中的环，寻找链表的中间节点等。
2. 左右指针（对撞指针）：

    一个指针从头部开始，另一个指针从尾部开始，向中间靠拢。
    常用于解决二分查找问题、两数之和、回文串判断等。
3. 滑动窗口：

    两个指针都从数组的同一侧开始，一个指针（窗口右边界）向前移动以扩大窗口，另一个指针（窗口左边界）根据需要移动以缩小窗口。
    常用于求解子数组、子字符串等问题。
#### 常见的应用场景
1. 两数之和：

    给定一个排序数组和一个目标值，找到两个数，使得它们的和等于目标值。可以使用左右指针法从两端开始寻找，找到符合条件的一对数。
2. 链表中的环检测：

    使用快慢指针法，快指针每次移动两步，慢指针每次移动一步。如果链表中有环，则快慢指针必定会相遇。
3. 最长无重复子串：

    使用滑动窗口法，通过两个指针确定当前不重复字符的范围，在遍历的过程中更新最长无重复子串的长度。

#### 经典题型
leecode 11. 16. 最接近的三数之和   42. 接雨水  75  80
### kmp算法

KMP算法（Knuth-Morris-Pratt算法）是一种用于在文本字符串中查找模式（子串）出现位置的高效算法。它通过利用部分匹配信息来避免不必要的重复匹配，从而提高匹配效率。KMP算法的时间复杂度为
O(n+m)，其中n 是文本字符串的长度，m 是模式字符串的长度。

#### KMP算法的核心思想
KMP算法的核心思想是部分匹配和前缀表。它利用已经匹配过的部分信息，在匹配失败时跳过一些字符，避免重复匹配。

1. 部分匹配：

    在暴力匹配算法中，如果在某个位置发现字符不匹配，通常是将模式字符串整体右移一位，然后从头开始比较。
    KMP算法通过记录已匹配的字符，知道在不匹配时模式字符串可以右移多少位，以避免已经匹配过的部分再次比较。
2. 前缀表（部分匹配表）：

    前缀表记录了模式字符串中每个位置之前的子串的前缀和后缀的最长公共部分的长度。这个长度告诉我们，如果在某个位置匹配失败，可以跳过多少个字符继续匹配。
    前缀表也被称为“失配表”或“next数组”。
##### 前缀表的构建
假设我们有一个模式字符串 p，构建前缀表 next，next[i] 表示在位置 i 之前的模式字符串的前缀和后缀的最长公共部分的长度。

next[0] 通常为 0，因为单个字符没有前缀和后缀。
对于其他位置 i，我们检查 p[0...i-1] 的前缀和后缀，找到最长的公共部分长度。

##### KMP匹配过程
在得到前缀表 next 之后，KMP算法的匹配过程如下：

初始化两个指针，i 指向文本字符串的当前字符，j 指向模式字符串的当前字符。
比较 text[i] 和 pattern[j]：
如果匹配成功（text[i] == pattern[j]），则同时移动 i 和 j，继续比较下一个字符。
如果匹配失败（text[i] != pattern[j]），则利用前缀表决定模式字符串应向右移动的位数：j = next[j-1]。如果 j == 0，则直接移动 i 继续比较。
如果 j 达到模式字符串的长度，说明找到了匹配，记录匹配的位置，然后继续从当前位置往后搜索。

##### 示例分析
给定文本字符串 text = "ABABDABACDABABCABAB" 和模式字符串 pattern = "ABABCABAB"：

构建前缀表 next 为 [0, 0, 1, 2, 0, 1, 2, 3, 4]。
在 text 中应用 KMP算法找到 pattern 的出现位置。
最终结果：pattern 在 text 中的索引 10 处出现。

#### 经典题型



### 动态规划
动态规划（Dynamic Programming, DP）是一种算法思想，用于解决具有重叠子问题和最优子结构性质的问题。它通过将复杂问题分解为更小的子问题，并利用子问题的解来构建原问题的解，从而避免重复计算，提高效率。

#### 动态规划的核心思想
1. 重叠子问题：

    问题可以分解为若干子问题，并且这些子问题会重复出现。如果直接递归求解，会造成大量重复计算，效率低下。
    通过记录已经解决的子问题的结果（通常使用一个表格或数组），可以避免重复计算，从而提高算法效率。

2. 最优子结构：

    问题的最优解可以通过其子问题的最优解来构建。即，问题的全局最优解包含了子问题的局部最优解。
    这意味着我们可以通过求解子问题的最优解来构建整体问题的最优解。

3. 状态转移方程：

    动态规划的核心是定义一个状态转移方程，它描述了如何通过子问题的解来构建原问题的解。状态转移方程是动态规划的关键步骤。

#### 动态规划的基本步骤

1. 定义状态：

    确定问题的子问题，并用一个或多个变量来表示这些子问题的状态。例如，在求解最长公共子序列问题时，状态可以用两个指针表示，分别指向两个字符串的当前字符。

2. 确定状态转移方程：

    找出子问题之间的关系，并用数学表达式描述这种关系，即状态转移方程。例如，在背包问题中，状态转移方程可以表示为在加入或不加入一个物品后的最优解比较。

3. 确定初始状态和边界条件：

    初始状态是递推的起点，通常与问题的最小子问题有关。边界条件是解决子问题时可能遇到的特殊情况或极端情况。

4. 计算最终结果：

    根据状态转移方程，从初始状态开始逐步计算，直到计算出原问题的解。通常通过填表法（如二维数组）完成。

#### 动态规划的分类
1. 自顶向下（Top-Down）：

    采用递归方式解决问题，从原问题开始，逐步分解为子问题。通常结合记忆化（Memoization）技术，即在递归过程中缓存子问题的结果，以避免重复计算。
    这种方法也称为“记忆化搜索”。

2. 自底向上（Bottom-Up）：

    采用迭代方式，从最小的子问题开始，逐步构建到原问题的解。通常使用一个表格或数组来存储子问题的结果。
    这种方法也称为“递推法”。

#### 动态规划的经典问题
1. 斐波那契数列：

    斐波那契数列是动态规划的一个经典示例，状态转移方程为：F(n) = F(n-1) + F(n-2)。

2. 背包问题：

    背包问题要求在给定容量的情况下，选择一定数量的物品使得总价值最大。状态转移方程为：dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])。

3. 最长公共子序列（LCS）：

    给定两个字符串，求它们的最长公共子序列。状态转移方程为：dp[i][j] = dp[i-1][j-1] + 1（若当前字符相等）；否则为max(dp[i-1][j], dp[i][j-1])。

4. 最小路径和：

    在一个二维网格中，每个格子都有一个非负整数，要求从左上角到右下角的路径，使得路径上的数字之和最小。状态转移方程为：dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]。

5. 股票买卖问题：

    给定一个数组表示股票的价格，求买卖股票的最大利润。这个问题有多种变体，如允许多次交易、只允许一次交易等。
#### 经典题型
leecode 10 44 72


### 滑动窗口

滑动窗口是一种常用的算法思想，特别适合解决涉及连续子数组或子序列的问题。滑动窗口的核心思想是维护一个窗口（可以是数组、字符串或其他序列的一部分），并通过在序列中移动这个窗口来动态地更新和计算结果，从而提高算法效率。

#### 滑动窗口的核心思想
1. 窗口的定义：

    滑动窗口通常是指序列中的一个子区间，代表当前关注的一部分数据。窗口可以通过设置两个指针（通常是左指针和右指针）来表示。

2. 窗口的移动：

    窗口在序列中向右移动，即右指针向右移动，每次增加一个新的元素进入窗口。
    当窗口不满足问题的要求时，可以通过移动左指针来缩小窗口，从而去除不需要的元素。

3. 窗口内的状态维护：

    在窗口移动的过程中，实时维护窗口内的数据状态（如窗口内元素的和、最大/最小值、出现频率等），以便快速获取需要的答案。
    通过动态更新窗口内的数据状态，可以避免重复计算，从而提高算法效率。

#### 滑动窗口的应用场景
滑动窗口特别适合解决以下类型的问题：

1. 子数组和子序列问题：

    例如，求解固定长度的子数组的最大和、最小和，或者最长满足某种条件的子数组长度。

2. 字符串问题：

    例如，求解字符串中的无重复字符的最长子串，找到字符串中包含某个子串的最小窗口等。

3. 双指针技巧结合：

    滑动窗口通常结合双指针技巧使用，通过左右两个指针控制窗口的扩展和收缩。

#### 滑动窗口的基本步骤
1. 初始化窗口和指针：

    通常，左指针和右指针都初始化为序列的起始位置。窗口开始为空。

2. 移动右指针扩展窗口：

    逐步将序列中的元素加入到窗口中，同时更新窗口内的状态。

3. 根据需要移动左指针收缩窗口：

    当窗口内的状态不满足问题的条件时，移动左指针缩小窗口，直到条件再次满足。
4. 实时更新结果：

    在每次窗口状态更新时，根据当前窗口的状态更新最终结果。例如，记录最大或最小的某个值。

5. 循环直到右指针遍历完整个序列：

    重复上述过程，直到右指针到达序列的末尾。

#### 滑动窗口的典型问题
1. 无重复字符的最长子串：

    问题描述：给定一个字符串，求出其中不含重复字符的最长子串的长度。
    思路：使用滑动窗口，右指针扩展窗口，当遇到重复字符时，移动左指针缩小窗口，直到窗口内无重复字符。

2. 找到字符串中所有字母异位词：

    问题描述：给定两个字符串 s 和 p，找到 s 中所有 p 的字母异位词的起始索引。
    思路：使用滑动窗口方法，窗口大小固定为 p 的长度，每次移动右指针时，检查窗口内的字符频率与 p 是否匹配。

3. 最大连续子数组和：

    问题描述：找到一个数组中和最大的连续子数组，并返回其和。
    思路：虽然这通常用“动态规划”解决，但滑动窗口也可以应用于优化和理解。

#### 经典题目
leecode 76

### 原地哈希

原地哈希是一种算法思想，通常用于解决与数组或列表相关的问题，特别是那些涉及查找或排序的问题。它的核心思想是通过元素交换或重新排列数组中的元素，将元素放置在“正确的位置”上，利用数组本身作为哈希表，从而达到节省空间的目的。

#### 原地哈希的核心思想
原地哈希的核心思想是通过数组元素的交换操作，将每个元素放置在它“应该在的位置”，从而使数组的状态反映出某种哈希结构或排序关系。因为所有操作都在原数组上进行，因此原地哈希的空间复杂度通常为
O(1)，这意味着不需要额外的存储空间。

#### 原地哈希的典型应用场景
1. 查找缺失的最小正整数： 给定一个未排序的数组，找出数组中未出现的最小正整数。例如，数组 [3, 4, -1, 1] 的结果应为 2。

2. 数组去重： 通过将元素放置在特定位置，可以有效去重，并使数组中的元素符合某种规则。

3. 重复元素查找： 利用元素交换，将每个元素放置在特定位置后，可以检测出数组中是否有重复元素。

#### 经典题目
leecode 41

### 贪心算法
贪心算法是一种通过局部最优选择来构建全局最优解的算法思想。它在每一步选择中都做出当前状态下最优的选择，并期望通过这种选择最终获得全局最优解。

#### 贪心算法的核心思想
1. 贪心选择性：

    每一步都选择当前状态下最优的选项，而不考虑未来的选择。这种选择是局部最优的，希望通过多个局部最优选择能构成一个全局最优解。

2. 最优子结构：

    问题的最优解可以通过子问题的最优解来构建。这意味着如果一个问题的最优解包含了子问题的最优解，贪心算法才适用。

3. 无后效性：

    当前的选择不会影响之后的选择，也就是说，之前的选择不会影响到当前的选择结果。

#### 贪心算法的步骤
1. 建立数学模型：

    首先，对问题进行建模，将问题转化为一系列可选的步骤。
2. 选择贪心策略：

    依据问题的具体情况，确定每一步最优选择的标准。
3. 验证局部最优能推导出全局最优：

    确保通过局部最优的选择能最终达到全局最优的解。
4. 实现贪心算法：

    通过迭代或递归方式进行贪心选择，直至构建出问题的全局解。

#### 贪心算法的典型应用
1. 活动选择问题：

    给定一组活动，每个活动有一个开始时间和结束时间。需要选择尽可能多的活动，在不重叠的情况下安排到一个时间段中。贪心策略是每次选择最早结束的活动。

2. 背包问题（0/1 背包问题的变种）：

    物品有不同的重量和价值，需要在容量固定的背包中装入尽可能多的物品，使得总价值最大。贪心策略是每次选择单位重量价值最高的物品装入背包。
3. 跳跃游戏：

    在跳跃游戏中，每一步贪心选择能跳到的最远距离，直到到达数组末尾。


#### 经典题目
leecode 45

### 二分法

二分法是一种高效的查找算法，通常用于在有序数组或有序范围内查找目标值。其核心思想是通过反复将查找范围对半分割来缩小目标搜索的范围，从而快速定位目标值。二分法的时间复杂度为 
O(logn)，是处理大规模数据查找问题的常用方法。

#### 二分法的核心思想
二分法的核心思想是分治法的一种应用，通过将问题不断分割为更小的子问题来解决。具体步骤如下：

1. 初始条件：

    假设数组或范围是有序的（从小到大或从大到小排列）。
    设置两个指针，left 指向范围的起始位置，right 指向范围的结束位置。
2. 计算中间位置：

    计算中间位置 mid：mid = left + (right - left) / 2。这种计算方式可以避免 (left + right) / 2 可能导致的整数溢出。
3. 比较中间值与目标值：

    如果 mid 对应的值 nums[mid] 恰好等于目标值 target，则直接返回 mid。
    如果 nums[mid] 小于 target，说明目标值在 mid 的右侧，因此将 left 更新为 mid + 1。
    如果 nums[mid] 大于 target，说明目标值在 mid 的左侧，因此将 right 更新为 mid - 1。
4. 重复步骤：

    不断重复上述步骤，直到 left 超过 right，说明目标值不存在于数组中，此时返回未找到的结果（如 -1 或其他约定的值）。

#### 经典题目
leecode 33 81


### 单调栈
单调栈是一种栈的应用，主要用于解决一类涉及“下一个更大元素”或“下一个更小元素”问题的场景。单调栈分为单调递增栈和单调递减栈两种，分别用于寻找下一个更大或更小的元素。

#### 单调栈的基本思想
单调递增栈：栈内元素从栈底到栈顶保持递增顺序。用于处理类似“下一个更大元素”的问题。
单调递减栈：栈内元素从栈底到栈顶保持递减顺序。用于处理类似“下一个更小元素”的问题。
通过维护栈的单调性，可以在遍历数组的过程中快速确定每个元素的相关信息（如下一个更大或更小的元素），从而有效地减少时间复杂度。

#### 单调栈的常见应用
1. 下一个更大元素：

    问题描述：给定一个数组，找到每个元素右边第一个比它大的元素。如果没有，则返回 -1。
    解法：使用单调递减栈。

2. 下一个更小元素：

    问题描述：给定一个数组，找到每个元素右边第一个比它小的元素。如果没有，则返回 -1。
    解法：使用单调递增栈。
3. 最大矩形面积（直方图问题）：

    问题描述：给定一个非负整数数组表示柱状图，找出柱状图中最大的矩形面积。
    解法：使用单调递增栈。

#### 经典题目
leecode 42 84